name: Discord Release Notification

on:
  release:
    types: [published]
  workflow_dispatch:  # Allows manual trigger

jobs:
  notify:
    runs-on: ubuntu-latest
    steps:
      - name: Get Release Information
        id: get_release
        run: |
          if [ "${{ github.event_name }}" == "release" ]; then
            # Use event data for automatic triggers
            echo "RELEASE_NAME=${{ github.event.release.name }}" >> $GITHUB_ENV
            echo "RELEASE_TAG=${{ github.event.release.tag_name }}" >> $GITHUB_ENV
            echo "RELEASE_BODY<<EOF" >> $GITHUB_ENV
            echo "${{ github.event.release.body }}" >> $GITHUB_ENV
            echo "EOF" >> $GITHUB_ENV
            echo "RELEASE_URL=${{ github.event.release.html_url }}" >> $GITHUB_ENV
            echo "RELEASE_AUTHOR=${{ github.event.release.author.login }}" >> $GITHUB_ENV
            echo "RELEASE_AUTHOR_AVATAR=${{ github.event.release.author.avatar_url }}" >> $GITHUB_ENV
            echo "ASSETS<<EOF" >> $GITHUB_ENV
            echo '${{ toJson(github.event.release.assets) }}' | jq -r 'map("[\(.name)](\(.browser_download_url))") | join("\n")' >> $GITHUB_ENV
            echo "EOF" >> $GITHUB_ENV
          else
            # Fetch latest release data for manual triggers
            RELEASE_DATA=$(curl -s -H "Authorization: token ${{ github.token }}" \
              "https://api.github.com/repos/${{ github.repository }}/releases/latest")
            
            echo "RELEASE_NAME=$(echo "$RELEASE_DATA" | jq -r '.name')" >> $GITHUB_ENV
            echo "RELEASE_TAG=$(echo "$RELEASE_DATA" | jq -r '.tag_name')" >> $GITHUB_ENV
            echo "RELEASE_BODY<<EOF" >> $GITHUB_ENV
            echo "$RELEASE_DATA" | jq -r '.body' >> $GITHUB_ENV
            echo "EOF" >> $GITHUB_ENV
            echo "RELEASE_URL=$(echo "$RELEASE_DATA" | jq -r '.html_url')" >> $GITHUB_ENV
            echo "RELEASE_AUTHOR=$(echo "$RELEASE_DATA" | jq -r '.author.login')" >> $GITHUB_ENV
            echo "RELEASE_AUTHOR_AVATAR=$(echo "$RELEASE_DATA" | jq -r '.author.avatar_url')" >> $GITHUB_ENV
            echo "ASSETS<<EOF" >> $GITHUB_ENV
            echo "$RELEASE_DATA" | jq -r '.assets | map("[\(.name)](\(.browser_download_url))") | join("\n")' >> $GITHUB_ENV
            echo "EOF" >> $GITHUB_ENV
          fi
          
      - name: Send Discord Notification
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
        run: |
          REPO_NAME="${{ github.repository }}"
          REPO_URL="https://github.com/${{ github.repository }}"
          TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

          # Get assets or set default message
          ASSETS="${{ env.ASSETS }}"
          if [ -z "$ASSETS" ]; then
            ASSETS="No downloadable assets"
          fi

          # Truncate release body if it exceeds Discord's 4096 character limit
          MAX_DESC_LENGTH=4000
          RELEASE_BODY=$(printf '%s' "${{ env.RELEASE_BODY }}")
          RELEASE_URL="${{ env.RELEASE_URL }}"

          if [ ${#RELEASE_BODY} -gt $MAX_DESC_LENGTH ]; then
            echo "Release body is ${#RELEASE_BODY} characters, truncating to $MAX_DESC_LENGTH"
            RELEASE_BODY=$(printf '%s' "${RELEASE_BODY:0:$MAX_DESC_LENGTH}... [Read full release notes]($RELEASE_URL)")
          else
            echo "Release body is ${#RELEASE_BODY} characters (within limit)"
          fi

          # Escape special characters for JSON
          RELEASE_BODY_ESCAPED=$(echo "$RELEASE_BODY" | jq -Rs .)
          ASSETS_ESCAPED=$(echo "$ASSETS" | jq -Rs .)
          
          # Create Discord embed JSON
          DISCORD_PAYLOAD=$(cat <<EOF
          {
            "embeds": [{
              "title": "ðŸš€ New Release: ${{ env.RELEASE_NAME }}",
              "description": $RELEASE_BODY_ESCAPED,
              "url": "${{ env.RELEASE_URL }}",
              "color": 3066993,
              "fields": [
                {
                  "name": "ðŸ“¦ Version",
                  "value": "\`${{ env.RELEASE_TAG }}\`",
                  "inline": true
                },
                {
                  "name": "ðŸ‘¤ Author",
                  "value": "[${{ env.RELEASE_AUTHOR }}](https://github.com/${{ env.RELEASE_AUTHOR }})",
                  "inline": true
                },
                {
                  "name": "ðŸ“‚ Repository",
                  "value": "[$REPO_NAME]($REPO_URL)",
                  "inline": false
                },
                {
                  "name": "â¬‡ï¸ Downloads",
                  "value": $ASSETS_ESCAPED,
                  "inline": false
                }
              ],
              "author": {
                "name": "${{ env.RELEASE_AUTHOR }}",
                "icon_url": "${{ env.RELEASE_AUTHOR_AVATAR }}",
                "url": "https://github.com/${{ env.RELEASE_AUTHOR }}"
              },
              "timestamp": "$TIMESTAMP",
              "footer": {
                "text": "Released from $REPO_NAME"
              }
            }]
          }
          EOF
          )
          
          # Send to Discord with error handling
          echo "Sending notification to Discord..."
          RESPONSE=$(curl -s -w "\n%{http_code}" -H "Content-Type: application/json" \
               -d "$DISCORD_PAYLOAD" \
               "$DISCORD_WEBHOOK_URL")

          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          RESPONSE_BODY=$(echo "$RESPONSE" | sed '$d')

          if [ "$HTTP_CODE" -eq 204 ] || [ "$HTTP_CODE" -eq 200 ]; then
            echo "Successfully sent Discord notification (HTTP $HTTP_CODE)"
          else
            echo "Failed to send Discord notification (HTTP $HTTP_CODE)"
            echo "Response: $RESPONSE_BODY"
            exit 1
          fi
